static asdl_seq* try_pattern_matching(struct compiling *c, const node* n, stmt_ty res, expr_ty target){
    const node *filter_node, *comp_node, *branch_filter, *branch_comp;
    expr_ty to_match, to_filter, to_comp;
    asdl_seq* case_body;
    int i, j, n_filters, n_comps;
    
    asdl_seq *to_match_seq;
    stmt_ty do_assign ;

    to_match = ast_for_expr(c, CHILD(n,1));
    if (!to_match)
        return NULL;
    if (!set_context(c, to_match, Store, CHILD(n, 1)))
        return NULL;
    to_match_seq = _Py_asdl_seq_new(1, c->c_arena);
    asdl_seq_SET(to_match_seq, 0, to_match);
    do_assign = Assign(to_match_seq, target, LINENO(n), n->n_col_offset, c->c_arena);
    

    filter_node = CHILD(n, 3);
    n_filters = 0;
    if (NCH(filter_node) == 3){
        goto filter_area; 
    }
    else{
        n_filters     = NCH(filter_node) - 1;
        branch_filter = filter_node;
        i = 2;
        
        loop_filters:
        if (i++ < n_filters){
            filter_node = CHILD(branch_filter, i);
            goto filter_area;
        }
        
    }
    if(0){        
        // parse matching filter(s)
        filter_area:
        to_filter = ast_for_expr(c, CHILD(filter_node, 0));
        if (!to_filter)
            return NULL;
        comp_node = CHILD(filter_node, 2);
        n_comps = 0;

        if (NCH(filter_node) == 4){
            goto comparing_area;
        }
        else{
            n_comps     = NCH(comp_node) - 1;
            branch_comp = comp_node;
            j = 2;

            loop_comparings:
            if (j++ < n_comps){
                comp_node = CHILD(branch_comp, j);
                goto comparing_area;
            }
        }

    }
    if(0){
        // parse comparing
        comparing_area:
        
        to_comp   = ast_for_expr(c, CHILD(comp_node   , 0));
        
        if (!to_comp)
            return NULL;
        

        case_body = ast_for_suite(c, CHILD(comp_node  , 3));
        
        if (!case_body)
            return NULL;
    }

    
    
    

}
Without multiple matching filters, we might have to write the following codes:
  ```C
    condic+(type) [1,2,3]:
        case (*a, b) -> b : float => ...
        case (*a, b) -> b : int   => ...
        case (*a, b) -> b : str   => ...
        case (*a, b) -> b : None.__class__ => ...

  ```
  After adding this grammar, we could do things like this:
  ```C
    condic+(type) [1,2,3]:
        case (*a, b) for
                b : float => ...
                b : int   => ...
                b : str   => ...
                b : None.__class__ =>  ...
  ```
  What's more:
  ```C
    condic+(type) [1,2,3]:
        case (*a, b) b :  
                float =>  ...
                int   =>  ...
                str   =>  ...
                None.__class__ => ...

    condic+(type) [1,2,3]:
        case (*a, b) for   
                b :     
                    float  => ...
                    int    => ...
                    str    => ...
                    None.__class__ => ...

                a : 
                    list    => ...
                    tuple   => ...
                       
  ```

| x == 1 =>  

